:awestruct-layout: project-releases-series
:awestruct-project: search
:awestruct-series_version: "6.2"
:page-interpolate: true
:hsearch-doc-url-prefix: #{reference_doc(site.projects[page.project], series(page, page.series_version)).html_url}

=== Dependency upgrades

[[orm-version]]
Hibernate ORM::
Hibernate Search still depends on Hibernate ORM 5.6 by default.
`-orm6` artifacts depend on Hibernate ORM 6.2.
[[lucene-version]]
Lucene::
The Lucene backend still uses Lucene 8.11.
[[elasticsearch-version]]
Elasticsearch::
The Elasticsearch backend now works with Elasticsearch 8.6 and 7.17
as well as other versions that were already compatible.
[[opensearch-version]]
OpenSearch::
The Elasticsearch backend now works with OpenSearch 1.3 and 2.5
as well as other versions that were already compatible.

[[mapper-pojo-standalone]]
=== Standalone POJO Mapper

The Standalone POJO Mapper enables mapping arbitrary POJOs to indexes.

Its key feature compared to the Hibernate ORM integration is its ability to run without Hibernate ORM or a relational database.
It can be used to index entities coming from an arbitrary datastore or even
(though thatâ€™s not recommended in general) to use Lucene or Elasticsearch as a primary datastore.

For more information about the Standalone POJO Mapper,
see link:{hsearch-doc-url-prefix}#mapper-pojo-standalone[this section of the reference documentation].

To get started with the Standalone POJO Mapper,
see link:{hsearch-doc-url-prefix}#mapper-pojo-standalone-getting-started[this getting started guide].

[[mapping-projection]]
=== Mapping index content to custom types (projection constructors)

Hibernate Search now offers the ability to define projections through the mapping of custom types (typically records),
by applying the `@ProjectionConstructor` annotation to those types or their constructor:

[source, JAVA, indent=0]
----
@ProjectionConstructor
public record MyBookProjection(String title, List<Author> authors) {
    @ProjectionConstructor
    public record Author(String firstName, String lastName) {
    }
}
----

Executing such a projection then becomes as easy as referencing the custom type:

[source, JAVA, indent=0]
----
List<MyBookProjection> hits = searchSession.search( Book.class )
        .select( MyBookProjection.class )
        .where( f -> f.matchAll() )
        .fetchHits( 20 );
----

See link:{hsearch-doc-url-prefix}#mapping-projection[this section of the reference documentation]
for more information.

[[mapping-improvements]]
=== Mapping improvements

Projectable fields::
All fields are now projectable by default with the Elasticsearch backend.
+
This change was made because making a field projectable doesn't incur any performance penalty with the Elasticsearch backend.
+
Since making a field projectable does have an impact on performance with the Lucene backend,
the defaults with the Lucene backend didn't change:
Lucene fields still need to be made projectable explicitly.

[[search-dsl-improvements]]
=== Search DSL improvements

[[predicate-and-or-not]]
Simpler boolean operators with the link:{hsearch-doc-url-prefix}#search-dsl-predicate-and[`and`]/link:{hsearch-doc-url-prefix}#search-dsl-predicate-or[`or`]/link:{hsearch-doc-url-prefix}#search-dsl-predicate-not[`not`] predicates::
For simpler use cases, you can now avoid the rather complex link:{hsearch-doc-url-prefix}#search-dsl-predicate-boolean[`bool` predicate]
and use the new link:{hsearch-doc-url-prefix}#search-dsl-predicate-and[`and`]/link:{hsearch-doc-url-prefix}#search-dsl-predicate-or[`or`]/link:{hsearch-doc-url-prefix}#search-dsl-predicate-not[`not`]
predicates instead:
+
[source, JAVA, indent=0]
----
List<Book> hits = searchSession.search( Book.class )
        .where( f -> f.and(
                        f.match().field( "title" )
                                .matching( "robot" ),
                        f.match().field( "description" )
                                .matching( "crime" )
        ) )
        .fetchHits( 20 );
----
+
[source, JAVA, indent=0]
----
List<Book> hits = searchSession.search( Book.class )
        .where( f -> f.or(
                        f.match().field( "title" )
                                .matching( "robot" ),
                        f.match().field( "description" )
                                .matching( "investigation" )
        ) )
        .fetchHits( 20 );
----
+
[source, JAVA, indent=0]
----
List<Book> hits = searchSession.search( Book.class )
        .where( f -> f.not(
                f.match()
                        .field( "genre" )
                        .matching( Genre.SCIENCE_FICTION )
        ) )
        .fetchHits( 20 );
----
[[predicate-bool-new-syntax-root]]
Shorter syntax for link:{hsearch-doc-url-prefix}#search-dsl-predicate-boolean-lambda[complex, root boolean predicates]::
Instead of `.where( f -> f.bool( b -> ... ) )`, you can now use `.where( (f, b) -> ... )`:
+
[source, JAVA, indent=0]
----
MySearchParameters searchParameters = getSearchParameters();
List<Book> hits = searchSession.search( Book.class )
        .where( (f, root) -> {
            root.add( f.matchAll() );
            if ( searchParameters.getGenreFilter() != null ) {
                root.add( f.match().field( "genre" )
                        .matching( searchParameters.getGenreFilter() ) );
            }
            if ( searchParameters.getFullTextFilter() != null ) {
                root.add( f.match().fields( "title", "description" )
                        .matching( searchParameters.getFullTextFilter() ) );
            }
            if ( searchParameters.getPageCountMaxFilter() != null ) {
                root.add( f.range().field( "pageCount" )
                        .atMost( searchParameters.getPageCountMaxFilter() ) );
            }
        } )
        .fetchHits( 20 );
----
+
The older syntax has been deprecated in favor of the new one.
[[predicate-bool-new-syntax-non-root]]
Clearer syntax for link:{hsearch-doc-url-prefix}#search-dsl-predicate-boolean-lambda[complex, non-root boolean predicates]::
Instead of `f.bool( b -> ... )`, you can now use `f.bool().with( b -> ... )`:
+
[source, JAVA, indent=0]
----
MySearchParameters searchParameters = getSearchParameters();
List<Book> hits = searchSession.search( Book.class )
        .where( (f, b) -> {
            b.must( f.matchAll() );
            if ( searchParameters.getGenreFilter() != null ) {
                b.must( f.match().field( "genre" )
                        .matching( searchParameters.getGenreFilter() ) );
            }
            if ( !searchParameters.getAuthorFilters().isEmpty() ) {
                b.must( f.bool().with( b2 -> {
                    for ( String authorFilter : searchParameters.getAuthorFilters() ) {
                        b2.should( f.match().fields( "authors.firstName", "authors.lastName" )
                                .matching( authorFilter ) );
                    }
                } ) );
            }
        } )
        .fetchHits( 20 );
----
+
The older syntax has been deprecated in favor of the new one.
[[predicate-nested-new-syntax]]
Clearer syntax for the link:{hsearch-doc-url-prefix}#search-dsl-predicate-nested[`nested` predicate]::
Instead of `f.nested().objectField( ... ).nest( f.bool().must( ... ) )`, you can now use `f.nested( ... ).add( ... )`:
+
[source, JAVA, indent=0]
----
List<Book> hits = searchSession.search( Book.class )
        .where( f -> f.nested( "authors" )
                .add( f.match().field( "authors.firstName" )
                        .matching( "isaac" ) )
                .add( f.match().field( "authors.lastName" )
                        .matching( "asimov" ) ) )
        .fetchHits( 20 );
----
+
The older syntax has been deprecated in favor of the new one.
[[predicate-matchnone]]
New link:{hsearch-doc-url-prefix}#search-dsl-predicate-match-none[`matchNone` predicate]::
The `matchNone` predicate matches no documents.
+
[source, JAVA, indent=0]
----
List<Book> hits = searchSession.search( Book.class )
        .where( f -> f.matchNone() )
        .fetchHits( 20 );
----
[[projection-composite-syntax]]
New syntax for link:{hsearch-doc-url-prefix}#search-dsl-projection-composite[composite projections]::
The definition of composite projections is now possible with a fluent syntax:
+
[source, JAVA, indent=0]
----
List<MyPair<String, Genre>> hits = searchSession.search( Book.class )
        .select( f -> f.composite()
                .from( f.field( "title", String.class ),
                        f.field( "genre", Genre.class ) )
                .as( MyPair::new ) )
        .where( f -> f.matchAll() )
        .fetchHits( 20 );
----
+
Most older syntaxes have been deprecated in favor of the new one.
[[projection-object]]
New link:{hsearch-doc-url-prefix}#search-dsl-projection-object[`object` projection]::
The `object` projection yields one projected value for each object in a given object field.
+
[source, JAVA, indent=0]
----
List<List<MyAuthorName>> hits = searchSession.search( Book.class )
        .select( f -> f.object( "authors" )
                .from( f.field( "authors.firstName", String.class ),
                        f.field( "authors.lastName", String.class ) )
                .as( MyAuthorName::new )
                .multi() )
        .where( f -> f.matchAll() )
        .fetchHits( 20 );
----
[[projection-constant]]
New link:{hsearch-doc-url-prefix}#search-dsl-projection-constant[`constant` projection]::
The `constant` projection returns the same value for every single document, the value being provided when defining the projection.
+
[source, JAVA, indent=0]
----
Instant searchRequestTimestamp = Instant.now();
List<MyPair<Integer, Instant>> hits = searchSession.search( Book.class )
        .select( f -> f.composite()
                .from( f.id( Integer.class ), f.constant( searchRequestTimestamp ) )
                .as( MyPair::new ) )
        .where( f -> f.matchAll() )
        .fetchHits( 20 );
----

[[mass-indexing-improvements]]
=== Mass indexing improvements

Mass indexing multiple tenants::
In multi-tenant applications, mass indexing can now handle multiple tenants at once,
provided you don't pass any tenant identifier when creating the mass indexer,
and you provided a list of tenants in the Hibernate Search configuration.
See link:{hsearch-doc-url-prefix}#indexing-massindexer-multitenancy[this section of the reference documentation]
for more information.
Setting up thread locals during mass indexing::
The mass indexer now has a concept of "mass indexing environment",
allowing for instance to set up custom thread locals in mass indexing threads.
See the `environment` parameter in link:{hsearch-doc-url-prefix}#indexing-massindexer-parameters[this section of the reference documentation]
for more information.
Better exception handling::
Exceptions thrown by Hibernate ORM during mass indexing
are now passed to the failure handler as every other exception, instead of aborting the whole mass indexing.
Smarter defaults for parameters::
`purgeAllOnStart` is now disabled by default in the mass indexer when `dropAndCreateSchemaOnStart` is enabled.

[[outbox-polling-improvements]]
=== `outbox-polling` coordination improvements

Outbox events and agents now use UUIDs for their identifiers::
The primary key of the relevant tables are now using UUIDs instead of longs,
to avoid reliance on sequences that were slowing down event processing on some databases.
The migration guide includes migration scripts for the necessary database schema changes.
Customizable database schema::
Simple, straightforward configuration properties now allow customizing the database schema involved in Hibernate Search's `outbox-polling` coordination strategy:
table names, schema and catalog, type of UUID columns as well as UUID generation strategy (random vs. time).
See link:{hsearch-doc-url-prefix}#_custom_schematable_nameetc[this section of the reference documentation]
for more information.
